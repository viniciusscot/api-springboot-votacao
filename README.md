# Api Springboot Votacao
Este projeto Ã© um microservice , e foi criado a partir das necessidades basicas de um microserviÃ§o, com cliente HTTP, persistÃªncia em banco de dados, 
mensageria utilizando kafka, e um schedulle que roda de 1 em 1 minuto.

# Arquitetura
Utilizamos como base, a implementaÃ§Ã£o da arquitetura hexagonal proposta pela Netflix, conheÃ§a um pouco mais clicando [aqui](https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749).

O modelo proposto pela Netflix, possui um isolamento baseado em dois conceitos, sendo eles: business-logic e adapters. Dado esse conceito,
fizemos uma pequena modificaÃ§Ã£o isolando os pacotes que fazem parte do business-logic no pacote `internal`, e os pacotes de fronteiras dentro do pacote `adapter`.

Abaixo, breve descriÃ§Ã£o da responsabilidade de cada camada.

- **Transport Layer**: Ã‰ a camada a qual aciona uma regra de negÃ³cio, sendo reponsÃ¡vel pela entrada de dados do mundo externo, para nossa aplicaÃ§Ã£o.
Aqui podem ficar nossos http providers, como por exemplo REST e GraphQL. Ou atÃ© mesmo consumers de message brokers como AWS SQS Listeners, Kafka Consumer e Redis Subscribers. 
  
- **Interactor**: ResponsÃ¡vel por parte da lÃ³gica de negÃ³cio, recebe os dados da camada de transport e delega, se necessÃ¡rio, para a camada de datasource. 

- **Entities**: ResponsÃ¡vel por mapear o nosso dominio e parte da lÃ³gica de negÃ³cio junto aos interactors. Devendo a todo custo
evitar dependÃªncias de frameworks e libs externas, ex: Lombok, notaÃ§Ãµes Spring e etc.

- **Datasource**: Ã‰ a camada que recebe um acionamento vindo de uma regra de negÃ³cio, responsÃ¡vel por direcionar o conteÃºdo
para a fonte de dados correta, podendo ser um AWS SQS Producer, AWS S3, arquivos CSV em disco, etc. *Esta camada pode ter mais de uma implementaÃ§Ã£o.*

```markdown
ğŸ“¦ src
â”£ ğŸ“¦ main/java/dev/zevolution/netflixhexaarch
â”ƒ â”£ ğŸ“‚ adapter: Adaptadores responsavÃ©is por acionar ou serem acionados a partir de eventos externos ou do bussiness-logic
â”ƒ â”ƒ â”£ ğŸ“‚ datasources: Todas as fontes de dados utilizadas pela aplicaÃ§Ã£o
â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ services: ServiÃ§o que podem vir a ser utilizados pelas fontes de dados, ex: uma class Feign Client
â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ data: DTO's de request e response utilizados pelos services acima
â”ƒ â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ request:
â”ƒ â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ response:
â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ mapper: Classes mapeadores, responsÃ¡veis por mapear os DTO's dos services, para entidades do bussiness-logic(internal)
â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ model: Classes responsÃ¡veis por mapear as entidades de banco de dados, aqui, podemos utilizar anotaÃ§Ãµes como @Entity, @Column, etc...
â”ƒ â”ƒ â”£ ğŸ“‚ properties: Classes responsÃ¡veis por mapear properties existentes no application.yml
â”ƒ â”ƒ â”£ ğŸ“‚ transportlayers: Todas as fontes para entrada de dados na nossa aplicaÃ§Ã£o, ex: Controllers, Consumers, Socket, etc ...
â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ mapper: Classes mapeadores, responsÃ¡veis por mapear os DTO's da transportlayer, para entidades do bussiness-logic(internal) e vice-versa
â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ restapi(example): Exemplo de onde podemos adicionar nossos Controllers
â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ messagebrokers(example): Exemplo de onde podemos adicionar nossos Listeners, Consumers e Subscribers
â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚ graphql(example): Exemplo de onde podemos adicionar nossos Controllers
â”ƒ â”£ ğŸ“‚ bootstrap: Classes de configuraÃ§Ã£o da aplicaÃ§Ã£o
â”ƒ â”ƒ â”£ ğŸ“‚ exceptions: ExceÃ§Ãµes da aplicaÃ§Ã£o, podendo ser compartilhada entre camadas
â”ƒ â”£ ğŸ“‚ internal: Contem tudo relacionado a Business-Logic
â”ƒ â”ƒ â”£ ğŸ“‚ entities: Classes utilizadas para mapeamento do nosso negÃ³cio/dominio
â”ƒ â”ƒ â”£ ğŸ“‚ interactors: Classes responsÃ¡vel por regras de negÃ³cio especificas
â”ƒ â”ƒ â”£ ğŸ“‚ properties: Classes responsÃ¡veis por mapear properties existentes no application.yml
â”ƒ â”ƒ â”£ ğŸ“‚ repositories: Interfaces responsÃ¡veis por especificar para o datasource, qual o input e retorno exigido pelo nosso domÃ­nio 
â”ƒ â”— ğŸ“œ Application.java: Classe inicializadora
â”£ ğŸ“¦ main/resources
â”ƒ â”£ ğŸ“œ application.yml
â”ƒ â”£ ğŸ“œ bootstrap.yml
â”ƒ â”— ğŸ“œ openapi.yml
â”£ ğŸ“œ .gitignore
â”£ ğŸ“œ Dockerfile
â”£ ğŸ“œ pom.xml
â”— ğŸ“œ README.MD
```

# Tecnologias
Foi utilizado na criaÃ§Ã£o deste chassis bibliotecas como: 

- [Java 11](https://openjdk.java.net/projects/jdk/11/)
- [Maven](https://maven.apache.org/)
- [Spring-Boot 2.5.0](https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/)
- [SpringFox 2.9.2](https://springfox.github.io/springfox/docs/2.9.2)
- [MapStruct](https://mapstruct.org/documentation/stable/reference/html/)
- [OpenFeign](https://spring.io/projects/spring-cloud-openfeign)
- [JUnit 5](https://junit.org/junit5/docs/current/user-guide/)
- [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)
- [Apache Kafka](https://kafka.apache.org/)
- [SonarQube](https://www.sonarqube.org/)
    * O chassis estÃ¡ gerando o cÃ³digo a partir da especificaÃ§Ã£o em `src/main/resources/openapi.yml`

# Build
Antes de subir a aplicaÃ§Ã£o, execute o comando `mvn clean install` ou mesmo o comando `mvn clean generate-sources` para gerar os stubs
utilizando OpenAPI-Generator-Tools, a partir do arquivo `openapi.yml`.

# Tests
Para realizar os testes, execute o comando `mvn clean install`, ele ja ira gerar os arquivos necessÃ¡rios,
e nÃ£o precisa se preocupar com as conexÃµes com o banco, ou kafka, que nos testes estou usando ambos embedded.

# URLs
 - DocumentaÃ§Ã£o swagger do prÃ³prio chassis: `http://localhost:8080/api-springboot-votacao/swagger-ui.html`